<!DOCTYPE html>
<html lang='en'>
<head>
    <meta charset='UTF-8'>
    <script src='d3.v3.min.js'></script>
    <title>Population Trends</title>
</head>
<body>
<div id='doughnut'></div>
<script>
    (function (d3) {
        /**
         * An array of country objects sorted by current population in non-ascending order.
         */
        var data = [];
        var data_year = 2015;
        var data_is_available = false;

        function compare_countries_by_population(a, b) { // Reversed natural ordering on current population
            if (a['current'] < b['current']) {
                return -1;
            } else if (a['current'] == b['current']) {
                return 0;
            } else {
                return 1;
            }
        }

        d3.json('processed.json', function (error, countries) {
            if (error) {
                console.log(error);
            } else {
                data = countries.sort(compare_countries_by_population).reverse();
                data_is_available = true;
                draw();
            }
        });

        /**
         * Simulates what the World's population is going to be like after the provided number of years has passed.
         */
        function interpolate_data(data, year_count) {
            data.map(function (country) {
                country['current'] = Math.pow(country['trend'], year_count) * country['current'];
                return country;
            });
            // Keep the data sorted for the drawing functions.
            data = data.sort(compare_countries_by_population).reverse();
            return data;
        }

        // The function that actually draws the graph
        // Should only be called after the data array has been initialized
        function draw() {
            var width = window.innerWidth;
            var height = window.innerHeight;
            var outer_radius = Math.min(width, height) * 0.4;
            var inner_radius = 0.5 * outer_radius;
            // Remove the old SVG, if it exists
            d3.select('svg').remove();
            var svg = d3.select('#doughnut')
                    .append('svg').attr('width', width).attr('height', height)
                    .append('g').attr('transform', 'translate(' + width / 2 + ',' + height / 2 + ')');

            var pie = d3.layout.pie().value(function (d) {
                return d.current;
            }).sort(null);

            var arc = d3.svg.arc().innerRadius(inner_radius).outerRadius(outer_radius);

            // Store one category instead of creating many.
            var color = d3.scale.category20b();

            // Make an array with the biggest countries and a group of the smaller
            var represented_country_count = 64;
            var processed_data = data.slice(0, represented_country_count);
            var unrepresented_current_population = 0;
            data.slice(represented_country_count).forEach(function (country) {
                unrepresented_current_population += country['current'];
            });
            processed_data.push({
                'current': unrepresented_current_population,
                'labels': ['Others', null],
                'trend': NaN // We do not compute this value.
            });
            var path = svg.selectAll('path').data(pie(processed_data)).enter()
                    .append('path')
                    .attr('d', arc)
                    .attr('fill', function (d) {
                        return color(d.data['labels'][1]);
                    });
            svg.selectAll('text').data([data_year]).enter()
                    .append('text')
                    .attr('text-anchor', 'middle') // Center horizontally
                    .attr('alignment-baseline', 'central') // Center vertically
                    .attr('font-family', 'sans-serif')
                    .attr('font-size', Math.floor(inner_radius / 2) + 'px') // Set a relative font-size
                    .text(function () {
                        return data_year;
                    });
        }

        /**
         * This function calls draw() to redraw the graph if the data is available.
         */
        function redraw() {
            if (data_is_available) {
                draw();
            }
        }

        window.addEventListener('resize', redraw);

        setInterval(function () {
            data = interpolate_data(data, 1);
            data_year += 1;
            redraw();
        }, 1000); // Increase year count after 1 second
    })(window.d3);
</script>
</body>
</html>
